### Eclipse Workspace Patch 1.0
#P org.eclipse.jdt.ui
Index: ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java,v
retrieving revision 1.9
diff -u -r1.9 ConfigureWorkingSetAction.java
--- ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java	18 Nov 2005 14:45:35 -0000	1.9
+++ ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java	8 Feb 2006 00:46:03 -0000
@@ -14,6 +14,8 @@
 import java.util.Arrays;
 import java.util.List;
 
+import org.eclipse.swt.widgets.Shell;
+
 import org.eclipse.jface.action.Action;
 import org.eclipse.jface.dialogs.IDialogConstants;
 
@@ -21,13 +23,18 @@
 import org.eclipse.ui.IWorkingSet;
 
 public class ConfigureWorkingSetAction extends Action {
-
-	private final IWorkbenchPartSite fSite;
+ 
 	private WorkingSetModel fWorkingSetModel;
+	private Shell fShell; 
 
 	public ConfigureWorkingSetAction(IWorkbenchPartSite site) {
 		super(WorkingSetMessages.ConfigureWorkingSetAction_label); 
-		fSite= site;
+		fShell= site.getShell();
+	}
+	
+	public ConfigureWorkingSetAction(Shell shell) {
+		super(WorkingSetMessages.ConfigureWorkingSetAction_label); 
+		fShell= shell;
 	}
 	
 	public void setWorkingSetModel(WorkingSetModel model) {
@@ -39,9 +46,10 @@
 	 */
 	public void run() {
 		List workingSets= new ArrayList(Arrays.asList(fWorkingSetModel.getAllWorkingSets()));
+
 		IWorkingSet[] activeWorkingSets= fWorkingSetModel.getActiveWorkingSets();
 		WorkingSetConfigurationDialog dialog= new WorkingSetConfigurationDialog(
-			fSite.getShell(), 
+			fShell, 
 			(IWorkingSet[])workingSets.toArray(new IWorkingSet[workingSets.size()]),
 			activeWorkingSets); 
 		dialog.setSelection(activeWorkingSets);
Index: ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java,v
retrieving revision 1.8
diff -u -r1.8 ViewActionGroup.java
--- ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java	13 Apr 2005 17:35:11 -0000	1.8
+++ ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java	8 Feb 2006 00:46:03 -0000
@@ -45,7 +45,12 @@
 
 	public ViewActionGroup(int mode, IPropertyChangeListener changeListener, IWorkbenchPartSite site) {
 		fChangeListener= changeListener;
-		fFilterActionGroup= new WorkingSetFilterActionGroup(site, changeListener);
+		if(fChangeListener == null) {
+			fChangeListener = new IPropertyChangeListener() {
+				public void propertyChange(PropertyChangeEvent event) {}
+			};
+		}
+		fFilterActionGroup= new WorkingSetFilterActionGroup(site, fChangeListener);
 		fShowActionGroup= new WorkingSetShowActionGroup(site);
 		fMode= mode;
 		if (showWorkingSets())
@@ -70,16 +75,24 @@
 	 */
 	public void fillActionBars(IActionBars actionBars) {
 		super.fillActionBars(actionBars);
-		fMenuManager= actionBars.getMenuManager();
-		IMenuManager showMenu= new MenuManager(WorkingSetMessages.ViewActionGroup_show_label); 
-		fillShowMenu(showMenu);
-		fMenuManager.add(showMenu);
-		fMenuManager.add(new Separator(IWorkingSetActionGroup.ACTION_GROUP));
+		if(fMenuManager == null) {
+			fMenuManager= actionBars.getMenuManager();
+			fillViewMenu(fMenuManager);
+		}
+
 		if (fActiveActionGroup == null)
 			fActiveActionGroup= fFilterActionGroup;
 		((ActionGroup)fActiveActionGroup).fillActionBars(actionBars);
 	}
 	
+	private void fillViewMenu(IMenuManager menu) { 
+		
+		IMenuManager showMenu= new MenuManager(WorkingSetMessages.ViewActionGroup_show_label); 
+		fillShowMenu(showMenu);
+		menu.add(showMenu);
+		menu.add(new Separator(IWorkingSetActionGroup.ACTION_GROUP));
+	}
+	
 	private void fillShowMenu(IMenuManager menu) {
 		ViewAction projects= new ViewAction(this, SHOW_PROJECTS);
 		projects.setText(WorkingSetMessages.ViewActionGroup_projects_label); 
@@ -116,7 +129,8 @@
 		}
 		fActiveActionGroup.fillViewMenu(fMenuManager);
 		fMenuManager.updateAll(true);
-		fChangeListener.propertyChange(event);
+		if(fChangeListener != null)
+			fChangeListener.propertyChange(event);
 	}
 	
 	public WorkingSetFilterActionGroup getFilterGroup() {
Index: ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java,v
retrieving revision 1.14
diff -u -r1.14 WorkingSetModel.java
--- ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java	26 Jan 2006 14:54:03 -0000	1.14
+++ ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java	8 Feb 2006 00:46:03 -0000
@@ -1,13 +1,11 @@
-/*******************************************************************************
- * Copyright (c) 2000, 2005 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
+/***************************************************************************************************
+ * Copyright (c) 2000, 2005 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
 package org.eclipse.jdt.internal.ui.workingsets;
 
 import java.util.ArrayList;
@@ -36,12 +34,12 @@
 import org.eclipse.ui.PlatformUI;
 
 public class WorkingSetModel {
-	
+
 	public static final String CHANGE_WORKING_SET_MODEL_CONTENT= "workingSetModelChanged"; //$NON-NLS-1$
-	
+
 	public static final IElementComparer COMPARER= new WorkingSetComparar();
-	
-	private static final String TAG_LOCAL_WORKING_SET_MANAGER= "localWorkingSetManager"; //$NON-NLS-1$
+
+	public static final String TAG_LOCAL_WORKING_SET_MANAGER= "localWorkingSetManager"; //$NON-NLS-1$
 	private static final String TAG_ACTIVE_WORKING_SET= "activeWorkingSet"; //$NON-NLS-1$
 	private static final String TAG_WORKING_SET_NAME= "workingSetName"; //$NON-NLS-1$
 	private static final String TAG_CONFIGURED= "configured"; //$NON-NLS-1$
@@ -53,28 +51,29 @@
 	private OthersWorkingSetUpdater fOthersWorkingSetUpdater;
 
 	private ElementMapper fElementMapper= new ElementMapper();
-	
+
 	private boolean fConfigured;
 
 	private static class WorkingSetComparar implements IElementComparer {
 		public boolean equals(Object o1, Object o2) {
-			IWorkingSet w1= o1 instanceof IWorkingSet ? (IWorkingSet)o1 : null;
-			IWorkingSet w2= o2 instanceof IWorkingSet ? (IWorkingSet)o2 : null;
+			IWorkingSet w1= o1 instanceof IWorkingSet ? (IWorkingSet) o1 : null;
+			IWorkingSet w2= o2 instanceof IWorkingSet ? (IWorkingSet) o2 : null;
 			if (w1 == null || w2 == null)
 				return o1.equals(o2);
 			return w1 == w2;
 		}
+
 		public int hashCode(Object element) {
 			if (element instanceof IWorkingSet)
 				return System.identityHashCode(element);
 			return element.hashCode();
 		}
 	}
-	
+
 	private static class ElementMapper {
 		private Map fElementToWorkingSet= new HashMap();
 		private Map fWorkingSetToElement= new IdentityHashMap();
-		
+
 		private Map fResourceToWorkingSet= new HashMap();
 
 		public void clear() {
@@ -82,14 +81,16 @@
 			fWorkingSetToElement.clear();
 			fResourceToWorkingSet.clear();
 		}
+
 		public void rebuild(IWorkingSet[] workingSets) {
 			clear();
 			for (int i= 0; i < workingSets.length; i++) {
 				put(workingSets[i]);
 			}
 		}
+
 		public IAdaptable[] remove(IWorkingSet ws) {
-			IAdaptable[] elements= (IAdaptable[])fWorkingSetToElement.remove(ws);
+			IAdaptable[] elements= (IAdaptable[]) fWorkingSetToElement.remove(ws);
 			if (elements != null) {
 				for (int i= 0; i < elements.length; i++) {
 					removeElement(elements[i], ws);
@@ -97,8 +98,9 @@
 			}
 			return elements;
 		}
+
 		public IAdaptable[] refresh(IWorkingSet ws) {
-			IAdaptable[] oldElements= (IAdaptable[])fWorkingSetToElement.get(ws);
+			IAdaptable[] oldElements= (IAdaptable[]) fWorkingSetToElement.get(ws);
 			if (oldElements == null)
 				return null;
 			IAdaptable[] newElements= ws.getElements();
@@ -106,15 +108,16 @@
 			List toAdd= new ArrayList(Arrays.asList(newElements));
 			computeDelta(toRemove, toAdd, oldElements, newElements);
 			for (Iterator iter= toAdd.iterator(); iter.hasNext();) {
-				addElement((IAdaptable)iter.next(), ws);
+				addElement((IAdaptable) iter.next(), ws);
 			}
 			for (Iterator iter= toRemove.iterator(); iter.hasNext();) {
-				removeElement((IAdaptable)iter.next(), ws);
+				removeElement((IAdaptable) iter.next(), ws);
 			}
 			if (toRemove.size() > 0 || toAdd.size() > 0)
 				fWorkingSetToElement.put(ws, newElements);
 			return oldElements;
 		}
+
 		private void computeDelta(List toRemove, List toAdd, IAdaptable[] oldElements, IAdaptable[] newElements) {
 			for (int i= 0; i < oldElements.length; i++) {
 				toAdd.remove(oldElements[i]);
@@ -122,20 +125,25 @@
 			for (int i= 0; i < newElements.length; i++) {
 				toRemove.remove(newElements[i]);
 			}
-			
+
 		}
+
 		public IWorkingSet getFirstWorkingSet(Object element) {
-			return (IWorkingSet)getFirstElement(fElementToWorkingSet, element);
+			return (IWorkingSet) getFirstElement(fElementToWorkingSet, element);
 		}
+
 		public List getAllWorkingSets(Object element) {
 			return getAllElements(fElementToWorkingSet, element);
 		}
+
 		public IWorkingSet getFirstWorkingSetForResource(IResource resource) {
-			return (IWorkingSet)getFirstElement(fResourceToWorkingSet, resource);
+			return (IWorkingSet) getFirstElement(fResourceToWorkingSet, resource);
 		}
+
 		public List getAllWorkingSetsForResource(IResource resource) {
 			return getAllElements(fResourceToWorkingSet, resource);
 		}
+
 		private void put(IWorkingSet ws) {
 			if (fWorkingSetToElement.containsKey(ws))
 				return;
@@ -145,20 +153,23 @@
 				addElement(elements[i], ws);
 			}
 		}
+
 		private void addElement(IAdaptable element, IWorkingSet ws) {
 			addToMap(fElementToWorkingSet, element, ws);
-			IResource resource= (IResource)element.getAdapter(IResource.class);
+			IResource resource= (IResource) element.getAdapter(IResource.class);
 			if (resource != null) {
 				addToMap(fResourceToWorkingSet, resource, ws);
 			}
 		}
+
 		private void removeElement(IAdaptable element, IWorkingSet ws) {
 			removeFromMap(fElementToWorkingSet, element, ws);
-			IResource resource= (IResource)element.getAdapter(IResource.class);
+			IResource resource= (IResource) element.getAdapter(IResource.class);
 			if (resource != null) {
 				removeFromMap(fResourceToWorkingSet, resource, ws);
 			}
 		}
+
 		private void addToMap(Map map, IAdaptable key, IWorkingSet value) {
 			Object obj= map.get(key);
 			if (obj == null) {
@@ -169,21 +180,22 @@
 				l.add(value);
 				map.put(key, l);
 			} else if (obj instanceof List) {
-				((List)obj).add(value);
+				((List) obj).add(value);
 			}
 		}
+
 		private void removeFromMap(Map map, IAdaptable key, IWorkingSet value) {
 			Object current= map.get(key);
 			if (current == null) {
 				return;
 			} else if (current instanceof List) {
-				List list= (List)current;
+				List list= (List) current;
 				list.remove(value);
 				switch (list.size()) {
-					case 0:
+					case 0 :
 						map.remove(key);
 						break;
-					case 1:
+					case 1 :
 						map.put(key, list.get(0));
 						break;
 				}
@@ -191,16 +203,18 @@
 				map.remove(key);
 			}
 		}
+
 		private Object getFirstElement(Map map, Object key) {
 			Object obj= map.get(key);
-			if (obj instanceof List) 
-				return ((List)obj).get(0);
+			if (obj instanceof List)
+				return ((List) obj).get(0);
 			return obj;
 		}
+
 		private List getAllElements(Map map, Object key) {
 			Object obj= map.get(key);
 			if (obj instanceof List)
-				return (List)obj;
+				return (List) obj;
 			if (obj == null)
 				return Collections.EMPTY_LIST;
 			List result= new ArrayList(1);
@@ -208,27 +222,27 @@
 			return result;
 		}
 	}
-	
+
 	public WorkingSetModel() {
 		fLocalWorkingSetManager= PlatformUI.getWorkbench().createLocalWorkingSetManager();
 		addListenersToWorkingSetManagers();
-    	fActiveWorkingSets= new ArrayList(2);
-    	
-    	IWorkingSet others= fLocalWorkingSetManager.createWorkingSet(WorkingSetMessages.WorkingSetModel_others_name, new IAdaptable[0]); 
-    	others.setId(OthersWorkingSetUpdater.ID);
-    	fLocalWorkingSetManager.addWorkingSet(others);
-    	fActiveWorkingSets.add(others);
-    	
-    	fOthersWorkingSetUpdater.init(this);
-    	fElementMapper.rebuild(getActiveWorkingSets());
+		fActiveWorkingSets= new ArrayList(2);
+
+		IWorkingSet others= fLocalWorkingSetManager.createWorkingSet(WorkingSetMessages.WorkingSetModel_others_name, new IAdaptable[0]);
+		others.setId(OthersWorkingSetUpdater.ID);
+		fLocalWorkingSetManager.addWorkingSet(others);
+		fActiveWorkingSets.add(others);
+
+		fOthersWorkingSetUpdater.init(this);
+		fElementMapper.rebuild(getActiveWorkingSets());
 	}
-	
+
 	public WorkingSetModel(IMemento memento) {
 		restoreState(memento);
 		fOthersWorkingSetUpdater.init(this);
-    	fElementMapper.rebuild(getActiveWorkingSets());
+		fElementMapper.rebuild(getActiveWorkingSets());
 	}
-	
+
 	private void addListenersToWorkingSetManagers() {
 		fListeners= new ListenerList(ListenerList.IDENTITY);
 		fWorkingSetManagerListener= new IPropertyChangeListener() {
@@ -239,7 +253,7 @@
 		PlatformUI.getWorkbench().getWorkingSetManager().addPropertyChangeListener(fWorkingSetManagerListener);
 		fLocalWorkingSetManager.addPropertyChangeListener(fWorkingSetManagerListener);
 	}
-	
+
 	public void dispose() {
 		if (fWorkingSetManagerListener != null) {
 			PlatformUI.getWorkbench().getWorkingSetManager().removePropertyChangeListener(fWorkingSetManagerListener);
@@ -248,118 +262,119 @@
 			fWorkingSetManagerListener= null;
 		}
 	}
-	
-	//---- model relationships ---------------------------------------
-	
+
+	// ---- model relationships ---------------------------------------
+
     public IAdaptable[] getChildren(IWorkingSet workingSet) {
-    	return workingSet.getElements();
-    }
-    
-    public Object getParent(Object element) {
-    	if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
-    		return this;
-    	return fElementMapper.getFirstWorkingSet(element);
-    }
-    
-    public Object[] getAllParents(Object element) {
-    	if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
-    		return new Object[] {this};
-    	return fElementMapper.getAllWorkingSets(element).toArray();
-    }
-    
-    public Object[] addWorkingSets(Object[] elements) {
-    	List result= null;
-    	for (int i= 0; i < elements.length; i++) {
-    		Object element= elements[i];
-    		List sets= null;
+		return workingSet.getElements();
+	}
+
+	public Object getParent(Object element) {
+		if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
+			return this;
+		return fElementMapper.getFirstWorkingSet(element);
+	}
+
+	public Object[] getAllParents(Object element) {
+		if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
+			return new Object[]{this};
+		return fElementMapper.getAllWorkingSets(element).toArray();
+	}
+
+	public Object[] addWorkingSets(Object[] elements) {
+		List result= null;
+		for (int i= 0; i < elements.length; i++) {
+			Object element= elements[i];
+			List sets= null;
 			if (element instanceof IResource) {
-    			sets= fElementMapper.getAllWorkingSetsForResource((IResource)element);
-    		} else {
-    			sets= fElementMapper.getAllWorkingSets(element);
-    		}
+				sets= fElementMapper.getAllWorkingSetsForResource((IResource) element);
+			} else {
+				sets= fElementMapper.getAllWorkingSets(element);
+			}
 			if (sets != null && sets.size() > 0) {
 				if (result == null)
 					result= new ArrayList(Arrays.asList(elements));
 				result.addAll(sets);
 			}
 		}
-    	if (result == null)
-    		return elements;
-    	return result.toArray();
-    }
-    
-    public boolean needsConfiguration() {
-    	return !fConfigured && fActiveWorkingSets.size() == 1 &&
-			OthersWorkingSetUpdater.ID.equals(((IWorkingSet)fActiveWorkingSets.get(0)).getId());
-    }
-    
-    public void configured() {
-    	fConfigured= true;
-    }
-    
-    //---- working set management -----------------------------------
-    
+		if (result == null)
+			return elements;
+		return result.toArray();
+	}
+
+	public boolean needsConfiguration() {
+		return !fConfigured && fActiveWorkingSets.size() == 1 && OthersWorkingSetUpdater.ID.equals(((IWorkingSet) fActiveWorkingSets.get(0)).getId());
+	}
+
+	public void configured() {
+		fConfigured= true;
+	}
+
+	// ---- working set management -----------------------------------
+
 	/**
-     * Adds a property change listener.
-     * 
-     * @param listener the property change listener to add
-     */
-    public void addPropertyChangeListener(IPropertyChangeListener listener) {
-    	fListeners.add(listener);
-    }
-    
-    /**
-     * Removes the property change listener.
-     * 
-     * @param listener the property change listener to remove
-     */
-    public void removePropertyChangeListener(IPropertyChangeListener listener) {
-    	fListeners.remove(listener);
-    }
-    
-    public IWorkingSet[] getActiveWorkingSets() {
-    	return (IWorkingSet[])fActiveWorkingSets.toArray(new IWorkingSet[fActiveWorkingSets.size()]);
-    }
-    
-    public IWorkingSet[] getAllWorkingSets() {
-    	List result= new ArrayList();
-    	result.addAll(fActiveWorkingSets);
-    	IWorkingSet[] locals= fLocalWorkingSetManager.getWorkingSets();
-    	for (int i= 0; i < locals.length; i++) {
+	 * Adds a property change listener.
+	 * 
+	 * @param listener
+	 *            the property change listener to add
+	 */
+	public void addPropertyChangeListener(IPropertyChangeListener listener) {
+		fListeners.add(listener);
+	}
+
+	/**
+	 * Removes the property change listener.
+	 * 
+	 * @param listener
+	 *            the property change listener to remove
+	 */
+	public void removePropertyChangeListener(IPropertyChangeListener listener) {
+		fListeners.remove(listener);
+	}
+
+	public IWorkingSet[] getActiveWorkingSets() {
+		return (IWorkingSet[]) fActiveWorkingSets.toArray(new IWorkingSet[fActiveWorkingSets.size()]);
+	}
+
+	public IWorkingSet[] getAllWorkingSets() {
+		List result= new ArrayList();
+		result.addAll(fActiveWorkingSets);
+		IWorkingSet[] locals= fLocalWorkingSetManager.getWorkingSets();
+		for (int i= 0; i < locals.length; i++) {
 			if (!result.contains(locals[i]))
 				result.add(locals[i]);
 		}
-    	IWorkingSet[] globals= PlatformUI.getWorkbench().getWorkingSetManager().getWorkingSets();
-    	for (int i= 0; i < globals.length; i++) {
+		IWorkingSet[] globals= PlatformUI.getWorkbench().getWorkingSetManager().getWorkingSets();
+		for (int i= 0; i < globals.length; i++) {
 			if (!result.contains(globals[i]))
 				result.add(globals[i]);
 		}
-    	return (IWorkingSet[])result.toArray(new IWorkingSet[result.size()]);
-    }
-    
-    public void setActiveWorkingSets(IWorkingSet[] workingSets) {
-    	fActiveWorkingSets= new ArrayList(Arrays.asList(workingSets));
-    	fElementMapper.rebuild(getActiveWorkingSets());
-    	fOthersWorkingSetUpdater.updateElements();
-    	fireEvent(new PropertyChangeEvent(this, CHANGE_WORKING_SET_MODEL_CONTENT, null, null));
-    }
-	
+		return (IWorkingSet[]) result.toArray(new IWorkingSet[result.size()]);
+	}
+
+	public void setActiveWorkingSets(IWorkingSet[] workingSets) {
+		fActiveWorkingSets= new ArrayList(Arrays.asList(workingSets));
+		fElementMapper.rebuild(getActiveWorkingSets());
+		fOthersWorkingSetUpdater.updateElements();
+		fireEvent(new PropertyChangeEvent(this, CHANGE_WORKING_SET_MODEL_CONTENT, null, null));
+	}
+
 	public void saveState(IMemento memento) {
 		memento.putString(TAG_CONFIGURED, Boolean.toString(fConfigured));
 		fLocalWorkingSetManager.saveState(memento.createChild(TAG_LOCAL_WORKING_SET_MANAGER));
 		for (Iterator iter= fActiveWorkingSets.iterator(); iter.hasNext();) {
 			IMemento active= memento.createChild(TAG_ACTIVE_WORKING_SET);
-			IWorkingSet workingSet= (IWorkingSet)iter.next();
+			IWorkingSet workingSet= (IWorkingSet) iter.next();
 			active.putString(TAG_WORKING_SET_NAME, workingSet.getName());
 		}
 	}
-	
+
 	private void restoreState(IMemento memento) {
 		String configured= memento.getString(TAG_CONFIGURED);
 		if (configured != null)
 			fConfigured= Boolean.valueOf(configured).booleanValue();
 		fLocalWorkingSetManager= PlatformUI.getWorkbench().createLocalWorkingSetManager();
-		addListenersToWorkingSetManagers();
+		addListenersToWorkingSetManagers(); 
 		fLocalWorkingSetManager.restoreState(memento.getChild(TAG_LOCAL_WORKING_SET_MANAGER));
 		IWorkingSet history= getHistoryWorkingSet();
 		if (history != null) {
@@ -380,54 +395,54 @@
 			}
 		}
 	}
-    private void workingSetManagerChanged(PropertyChangeEvent event) {
+
+	private void workingSetManagerChanged(PropertyChangeEvent event) {
 		String property= event.getProperty();
-    	if (IWorkingSetManager.CHANGE_WORKING_SET_UPDATER_INSTALLED.equals(property) && event.getSource() == fLocalWorkingSetManager) {
-			IWorkingSetUpdater updater= (IWorkingSetUpdater)event.getNewValue();
+		if (IWorkingSetManager.CHANGE_WORKING_SET_UPDATER_INSTALLED.equals(property) && event.getSource() == fLocalWorkingSetManager) {
+			IWorkingSetUpdater updater= (IWorkingSetUpdater) event.getNewValue();
 			if (updater instanceof OthersWorkingSetUpdater) {
-				fOthersWorkingSetUpdater= (OthersWorkingSetUpdater)updater;
+				fOthersWorkingSetUpdater= (OthersWorkingSetUpdater) updater;
 			}
 			return;
 		}
-    	// don't handle working sets not managed by the model
-    	if (!isAffected(event))
-    		return;
-    	
+		// don't handle working sets not managed by the model
+		if (!isAffected(event))
+			return;
+
 		if (IWorkingSetManager.CHANGE_WORKING_SET_CONTENT_CHANGE.equals(property)) {
-			IWorkingSet workingSet= (IWorkingSet)event.getNewValue();
+			IWorkingSet workingSet= (IWorkingSet) event.getNewValue();
 			IAdaptable[] elements= fElementMapper.refresh(workingSet);
 			if (elements != null) {
 				fireEvent(event);
 			}
 		} else if (IWorkingSetManager.CHANGE_WORKING_SET_REMOVE.equals(property)) {
-			IWorkingSet workingSet= (IWorkingSet)event.getOldValue();
+			IWorkingSet workingSet= (IWorkingSet) event.getOldValue();
 			List elements= new ArrayList(fActiveWorkingSets);
 			elements.remove(workingSet);
-			setActiveWorkingSets((IWorkingSet[])elements.toArray(new IWorkingSet[elements.size()]));
-    	} else if (IWorkingSetManager.CHANGE_WORKING_SET_NAME_CHANGE.equals(property)) {
+			setActiveWorkingSets((IWorkingSet[]) elements.toArray(new IWorkingSet[elements.size()]));
+		} else if (IWorkingSetManager.CHANGE_WORKING_SET_NAME_CHANGE.equals(property)) {
 			fireEvent(event);
 		}
 	}
-    
-    private void fireEvent(PropertyChangeEvent event) {
-    	Object[] listeners= fListeners.getListeners();
-    	for (int i= 0; i < listeners.length; i++) {
-			((IPropertyChangeListener)listeners[i]).propertyChange(event);
-		}
-    }
-    
-    private boolean isAffected(PropertyChangeEvent event) {
-    	if (fActiveWorkingSets == null)
-    		return false;
-    	Object oldValue= event.getOldValue();
-    	Object newValue= event.getNewValue();
-    	if ((oldValue != null && fActiveWorkingSets.contains(oldValue)) 
-    		|| (newValue != null && fActiveWorkingSets.contains(newValue))) {
-    		return true;
-    	}
-    	return false;
-    }
-	
+
+	private void fireEvent(PropertyChangeEvent event) {
+		Object[] listeners= fListeners.getListeners();
+		for (int i= 0; i < listeners.length; i++) {
+			((IPropertyChangeListener) listeners[i]).propertyChange(event);
+		}
+	}
+
+	private boolean isAffected(PropertyChangeEvent event) {
+		if (fActiveWorkingSets == null)
+			return false;
+		Object oldValue= event.getOldValue();
+		Object newValue= event.getNewValue();
+		if ((oldValue != null && fActiveWorkingSets.contains(oldValue)) || (newValue != null && fActiveWorkingSets.contains(newValue))) {
+			return true;
+		}
+		return false;
+	}
+
 	private IWorkingSet getHistoryWorkingSet() {
 		IWorkingSet[] workingSets= fLocalWorkingSetManager.getWorkingSets();
 		for (int i= 0; i < workingSets.length; i++) {
Index: ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java,v
retrieving revision 1.50
diff -u -r1.50 PackageExplorerContentProvider.java
--- ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java	11 Jan 2006 15:49:15 -0000	1.50
+++ ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java	8 Feb 2006 00:46:03 -0000
@@ -76,14 +76,22 @@
 	private PackageFragmentProvider fPackageFragmentProvider= new PackageFragmentProvider();
 	
 	private int fPendingChanges;
-	PackageExplorerPart fPart;
+	//PackageExplorerPart fPart;
+	
+	/**
+	 * Creates a new content provider for Java elements.
+	 */
+	public PackageExplorerContentProvider(boolean provideMembers) {
+		super(provideMembers);	
+		//fPart= part;
+	}
 	
 	/**
 	 * Creates a new content provider for Java elements.
 	 */
 	public PackageExplorerContentProvider(PackageExplorerPart part, boolean provideMembers) {
 		super(provideMembers);	
-		fPart= part;
+		//fPart= part;
 	}
 	
 	/* package */ PackageFragmentProvider getPackageFragmentProvider() {
@@ -620,7 +628,7 @@
 		});
 	}
 
-	private void postAdd(final Object parent, final Object element) {
+	/* package */ void postAdd(final Object parent, final Object element) {
 		postRunnable(new Runnable() {
 			public void run() {
 				Control ctrl= fViewer.getControl();
@@ -647,7 +655,14 @@
 	private void postProjectStateChanged(final Object root) {
 		postRunnable(new Runnable() {
 			public void run() {
-				fPart.projectStateChanged(root);
+				//fPart.projectStateChanged(root); 
+				Control ctrl= fViewer.getControl();
+				if (ctrl != null && !ctrl.isDisposed()) {
+					fViewer.refresh(root, true);
+					// trigger a syntetic selection change so that action refresh their
+					// enable state.
+					fViewer.setSelection(fViewer.getSelection());
+				}
 			}
 		});
 	}
Index: plugin.xml
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/plugin.xml,v
retrieving revision 1.617
diff -u -r1.617 plugin.xml
--- plugin.xml	5 Feb 2006 18:11:23 -0000	1.617
+++ plugin.xml	8 Feb 2006 00:46:02 -0000
@@ -5047,4 +5047,97 @@
       </objectContribution>
    </extension>
 
+
+    <!-- ADDITIONS BELOW THIS LINE -->
+      
+    <extension
+          point="org.eclipse.ui.navigator.viewer">
+       <viewerContentBinding 
+             viewerId="org.eclipse.ui.navigator.resourceContent">
+          <includes>
+       	      <contentExtension pattern="org.eclipse.jdt.java.ui.javaContent" />       
+          </includes>       
+       </viewerContentBinding>
+    </extension> 
+      
+    <extension
+          point="org.eclipse.ui.navigator.navigatorContent">
+       <navigatorContent
+             activeByDefault="true"
+             contentProvider="org.eclipse.jdt.internal.ui.packageview.PreferenceAwareContentProvider"
+             icon="$nl$/icons/full/obj16/java_model.gif"
+             id="org.eclipse.jdt.java.ui.javaContent"
+             labelProvider="org.eclipse.jdt.internal.ui.packageview.PreferenceAwareLabelProvider"
+             name="Java Elements"
+             priority="high">
+          <triggerPoints> 
+	         <or>           
+               <adapt 
+	                     type="org.eclipse.core.resources.IProject" > 
+		                  <test
+		                     property="org.eclipse.core.resources.projectNature"
+		                     value="org.eclipse.jdt.core.javanature" />
+               </adapt>             
+	           <instanceof 
+	                 value="org.eclipse.core.resources.IWorkspaceRoot" /> 
+	                 
+	           <instanceof
+	                 value="org.eclipse.core.resources.IFolder" /> 
+	           <instanceof
+	                value="org.eclipse.core.resources.IFile" /> 
+	           <instanceof 
+	                 value="org.eclipse.jdt.core.IJavaProject" /> 
+	           <instanceof 
+	                 value="org.eclipse.jdt.core.IJavaElement" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.internal.core.JarEntryFile" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.core.IClassFile" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.internal.ui.packageview.ClassPathContainer" /> 
+	            <!--
+				<instanceof 
+ 					value="org.eclipse.jdt.internal.ui.workingsets.WorkingSetModel" /> 
+ 					-->
+	         </or>
+          </triggerPoints>
+          <possibleChildren> 
+	         <or>           
+               <adapt 
+					type="org.eclipse.core.resources.IProject" >  
+               </adapt>             
+	           <instanceof 
+	                 value="org.eclipse.core.resources.IWorkspaceRoot" /> 	                 
+	           <instanceof
+	                 value="org.eclipse.core.resources.IFolder" /> 
+	           <instanceof
+	                value="org.eclipse.core.resources.IFile" /> 
+	           <instanceof 
+	                 value="org.eclipse.jdt.core.IJavaProject" /> 
+	           <instanceof 
+	                 value="org.eclipse.jdt.core.IJavaElement" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.internal.core.JarEntryFile" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.core.IClassFile" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.internal.ui.packageview.ClassPathContainer" />  
+	         </or>
+          </possibleChildren>          
+          <actionProvider 
+	               class="org.eclipse.jdt.internal.ui.packageview.PackageExplorerActionProvider">
+	               <enablement>	               
+	               <adapt 
+	                     type="org.eclipse.jdt.core.IJavaElement" /> 
+	               </enablement>
+          </actionProvider>
+          <override
+                policy="InvokeAlwaysRegardlessOfSuppressedExt"
+                suppressedExtensionId="org.eclipse.ui.navigator.resourceContent"/>
+          <commonSorter
+                class="org.eclipse.jdt.ui.JavaElementSorter"
+                id="org.eclipse.jdt.ui.javaElementSorter"/> 
+       </navigatorContent>
+    </extension>
+     
 </plugin>
\ No newline at end of file
Index: ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java,v
retrieving revision 1.7
diff -u -r1.7 MultiActionGroup.java
--- ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java	17 Jun 2005 15:51:51 -0000	1.7
+++ ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java	8 Feb 2006 00:46:02 -0000
@@ -37,6 +37,8 @@
  */
 public class MultiActionGroup extends ActionGroup {
 	
+	public IAction[] NO_ACTIONS = new IAction[0];
+	
 	private IAction[] fActions; 
 	
 	private int fCurrentSelection;
@@ -57,6 +59,32 @@
 		fCurrentSelection= currentSelection;
 		fActions= actions;
 	}
+	
+	/**
+	 * Creates a new action group with a given set of actions.
+	 * 
+	 * @param actions			the actions for this multi group
+	 * @param currentSelection	decides which action is selected in the menu on start up.
+	 * 							Denotes the location in the actions array of the current
+	 * 							selected state. It cannot be null.
+	 */
+	public MultiActionGroup(int currentSelection) {
+		super();
+		
+		fCurrentSelection= currentSelection;
+		fActions= NO_ACTIONS;
+	}
+	
+	/**
+	 * 
+	 * @param actions			the actions for this multi group 
+	 */
+	protected final void setActions(IAction[] actions) {
+		if(actions != null)
+			fActions = actions;
+		else
+			fActions = NO_ACTIONS;
+	}
 
 	/**
 	 * Add the actions to the given menu manager.
Index: ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,131 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.viewers.StructuredViewer;
+
+import org.eclipse.ui.IActionBars;
+import org.eclipse.ui.IWorkbenchActionConstants;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+
+import org.eclipse.jdt.internal.ui.IJavaHelpContextIds;
+import org.eclipse.jdt.internal.ui.JavaPluginImages;
+import org.eclipse.jdt.internal.ui.actions.MultiActionGroup;
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+
+/**
+ * Adds view menus to switch between flat and hierarchical layout.
+ * 
+ * @since 2.1
+ */
+public class CommonLayoutActionGroup extends MultiActionGroup {
+
+	private boolean fHasContributedToViewMenu = false;
+	private IAction fHierarchicalLayout = null;
+	private IAction fFlatLayoutAction = null; 
+
+	public CommonLayoutActionGroup(StructuredViewer structuredViewer, IExtensionStateModel stateModel) {
+		super(stateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT) ? 0 : 1);
+		IAction[] actions = createActions(structuredViewer, stateModel);
+		setActions(actions); 
+	}
+
+	/* (non-Javadoc)
+	 * @see ActionGroup#fillActionBars(IActionBars)
+	 */
+	public void fillActionBars(IActionBars actionBars) {
+		super.fillActionBars(actionBars);
+		if(!fHasContributedToViewMenu) {
+			synchronized(this) {
+				if(!fHasContributedToViewMenu) {
+					fHasContributedToViewMenu = true;
+					contributeToViewMenu(actionBars.getMenuManager());
+				}
+			}
+		}
+	}
+	
+	private void contributeToViewMenu(IMenuManager viewMenu) {
+		viewMenu.add(new Separator());
+
+		// Create layout sub menu
+		
+		IMenuManager layoutSubMenu= new MenuManager(PackagesMessages.LayoutActionGroup_label); 
+		final String layoutGroupName= "layout"; //$NON-NLS-1$
+		Separator marker= new Separator(layoutGroupName);
+
+		viewMenu.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
+		viewMenu.add(marker);
+		viewMenu.appendToGroup(layoutGroupName, layoutSubMenu);
+		viewMenu.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS+"-end"));//$NON-NLS-1$		
+		addActions(layoutSubMenu);
+	}
+	
+	
+	private IAction[] createActions(StructuredViewer structuredViewer, IExtensionStateModel stateModel) {
+		
+		fFlatLayoutAction= new CommonLayoutAction(structuredViewer, stateModel, true);
+		fFlatLayoutAction.setText(PackagesMessages.LayoutActionGroup_flatLayoutAction_label); 
+		JavaPluginImages.setLocalImageDescriptors(fFlatLayoutAction, "flatLayout.gif"); //$NON-NLS-1$
+		
+		fHierarchicalLayout= new CommonLayoutAction(structuredViewer, stateModel, false);
+		fHierarchicalLayout.setText(PackagesMessages.LayoutActionGroup_hierarchicalLayoutAction_label);	  
+		JavaPluginImages.setLocalImageDescriptors(fHierarchicalLayout, "hierarchicalLayout.gif"); //$NON-NLS-1$
+		
+		fHierarchicalLayout.setChecked(!stateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT));
+		fFlatLayoutAction.setChecked(stateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT));
+		
+		return new IAction[]{fFlatLayoutAction, fHierarchicalLayout};
+	}
+	
+	public void setFlatLayout(boolean flatLayout) {
+		fHierarchicalLayout.setChecked(!flatLayout);
+		fFlatLayoutAction.setChecked(flatLayout);
+	}
+	 
+}
+
+class CommonLayoutAction extends Action implements IAction {
+
+	private final boolean fIsFlatLayout;
+	private IExtensionStateModel fStateModel;
+	private StructuredViewer fStructuredViewer;
+
+	public CommonLayoutAction(StructuredViewer structuredViewer, IExtensionStateModel stateModel, boolean flat) {
+		super("", AS_RADIO_BUTTON); //$NON-NLS-1$
+		fStateModel = stateModel;
+		fStructuredViewer = structuredViewer;
+		fIsFlatLayout= flat; 
+		if (fIsFlatLayout)
+			PlatformUI.getWorkbench().getHelpSystem().setHelp(this, IJavaHelpContextIds.LAYOUT_FLAT_ACTION);
+		else
+			PlatformUI.getWorkbench().getHelpSystem().setHelp(this, IJavaHelpContextIds.LAYOUT_HIERARCHICAL_ACTION);
+	}
+
+	/*
+	 * @see org.eclipse.jface.action.IAction#run()
+	 */
+	public void run() {
+		if (fStateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT) != fIsFlatLayout) {
+			fStateModel.setBooleanProperty(Values.IS_LAYOUT_FLAT, fIsFlatLayout);
+  			 	
+			fStructuredViewer.getControl().setRedraw(false);
+			fStructuredViewer.refresh();
+			fStructuredViewer.getControl().setRedraw(true);
+		}
+	}
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,174 @@
+/***************************************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspaceRoot;
+
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.jface.viewers.Viewer;
+
+import org.eclipse.ui.IMemento;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+import org.eclipse.ui.navigator.IPipelinedTreeContentProvider;
+import org.eclipse.ui.navigator.PipelinedShapeModification;
+import org.eclipse.ui.navigator.PipelinedViewerUpdate;
+
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaModel;
+import org.eclipse.jdt.core.JavaCore;
+
+import org.eclipse.jdt.ui.PreferenceConstants;
+
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+
+public class PreferenceAwareContentProvider extends
+		PackageExplorerContentProvider implements IPipelinedTreeContentProvider {
+
+	public PreferenceAwareContentProvider() {
+		super(false);
+	}
+
+	public PreferenceAwareContentProvider(boolean provideMembers) {
+		super(provideMembers);
+	}
+
+	public static final String JDT_EXTENSION_ID = "org.eclipse.jdt.ui.javaContent"; //$NON-NLS-1$ 
+
+	private IExtensionStateModel fStateModel;
+
+	public void init(IExtensionStateModel stateModel, IMemento memento) {
+		fStateModel = stateModel;
+		// fManager = new WorkingSetModelManager(fStateModel, this);
+		// expose the manager for the action provider
+		// fStateModel.setProperty(WorkingSetModelManager.INSTANCE_KEY,
+		// fManager);
+		restoreState(memento);
+		fStateModel.addPropertyChangeListener(new IPropertyChangeListener() {
+			public void propertyChange(PropertyChangeEvent event) {
+				if (Values.IS_LAYOUT_FLAT.equals(event.getProperty())) {
+					if (event.getNewValue() != null) {
+						boolean newValue = ((Boolean) event.getNewValue())
+								.booleanValue() ? true : false;
+						setIsFlatLayout(newValue);
+					}
+				}
+
+			}
+		});
+
+		IPreferenceStore store = PreferenceConstants.getPreferenceStore();
+		boolean showCUChildren = store
+				.getBoolean(PreferenceConstants.SHOW_CU_CHILDREN);
+		setProvideMembers(showCUChildren);
+	}
+
+	public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
+		super.inputChanged(viewer, oldInput, findInputElement(newInput));
+	}
+
+	public Object[] getElements(Object inputElement) {
+		if (inputElement instanceof IWorkspaceRoot)
+			return super.getElements(JavaCore
+					.create((IWorkspaceRoot) inputElement));
+		return super.getElements(inputElement);
+	}
+
+	private Object findInputElement(Object newInput) {
+		if (newInput instanceof IWorkspaceRoot) {
+			return JavaCore.create((IWorkspaceRoot) newInput);
+		}
+		return newInput;
+	}
+
+	public void restoreState(IMemento memento) {
+
+	}
+
+	public void saveState(IMemento memento) {
+
+	}
+
+	public void getPipelinedChildren(Object parent, Set currentChildren) {
+		Object[] children = getChildren(parent);
+		for (Iterator iter = currentChildren.iterator(); iter.hasNext();)
+			if (iter.next() instanceof IResource)
+				iter.remove();
+		currentChildren.addAll(Arrays.asList(children));
+	}
+
+	public void getPipelinedElements(Object input, Set currentElements) {
+		Object[] children = getElements(input);
+
+		for (Iterator iter = currentElements.iterator(); iter.hasNext();)
+			if (iter.next() instanceof IResource)
+				iter.remove();
+
+		currentElements.addAll(Arrays.asList(children));
+	}
+
+	public Object getPipelinedParent(Object object, Object suggestedParent) {
+		return getParent(object);
+	}
+
+	public PipelinedShapeModification interceptAdd(
+			PipelinedShapeModification anAddModification) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public PipelinedShapeModification interceptRemove(
+			PipelinedShapeModification aRemoveModification) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public boolean interceptRefresh(
+			PipelinedViewerUpdate aRefreshSynchronization) {
+		IJavaElement javaElement;
+		Set interceptedElements = new HashSet();
+		for (Iterator iter = aRefreshSynchronization.getRefreshTargets()
+				.iterator(); iter.hasNext();) {
+			Object element = iter.next();
+			if (element instanceof IResource) {
+				if ((javaElement = JavaCore.create((IResource) element)) != null && javaElement.exists()) {
+					iter.remove();
+					interceptedElements.add(javaElement);
+				}
+			}
+		}
+		if (interceptedElements.size() > 0) {
+			aRefreshSynchronization.getRefreshTargets().addAll(
+					interceptedElements);
+			return true;
+		}
+		return false;
+
+	}
+
+	public boolean interceptUpdate(PipelinedViewerUpdate anUpdateSynchronization) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	/* package */void postAdd(final Object parent, final Object element) {
+		if (parent instanceof IJavaModel)
+			super.postAdd(((IJavaModel) parent).getWorkspace(), element);
+		else
+			super.postAdd(parent, element);
+	}
+
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,126 @@
+/***************************************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.viewers.StructuredViewer;
+
+import org.eclipse.ui.IActionBars;
+import org.eclipse.ui.IMemento;
+import org.eclipse.ui.IViewPart;
+import org.eclipse.ui.navigator.CommonActionProvider;
+import org.eclipse.ui.navigator.CommonActionProviderConfig;
+import org.eclipse.ui.navigator.ICommonViewerWorkbenchSite;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+import org.eclipse.ui.navigator.INavigatorContentService;
+
+import org.eclipse.jdt.ui.actions.CCPActionGroup;
+
+import org.eclipse.jdt.internal.ui.JavaPlugin;
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+import org.eclipse.jdt.internal.ui.workingsets.ViewActionGroup;
+
+public class PackageExplorerActionProvider extends CommonActionProvider { 
+
+	private static final int HIERARCHICAL_LAYOUT = 0x1;
+
+	private static final int FLAT_LAYOUT = 0x2;
+
+	private static final String TAG_LAYOUT = "layout"; //$NON-NLS-1$
+
+	private ViewActionGroup fViewActionGroup;
+
+	private CommonLayoutActionGroup fLayoutActionGroup;
+
+	private boolean fHasFilledViewMenu = false;
+
+	private IExtensionStateModel fStateModel;
+
+	private CCPActionGroup fCCPGroup;
+
+	public void fillActionBars(IActionBars actionBars) {
+		if (!fHasFilledViewMenu) {
+			if(fViewActionGroup != null)
+				fViewActionGroup.fillActionBars(actionBars);
+			fLayoutActionGroup.fillActionBars(actionBars);
+			fHasFilledViewMenu = true;
+		}
+
+	}
+
+	public void fillContextMenu(IMenuManager menu) {
+
+		if(fCCPGroup != null)
+			fCCPGroup.fillContextMenu(menu);
+
+	}
+
+	public void init(CommonActionProviderConfig config) {
+
+		ICommonViewerWorkbenchSite workbenchSite = null;
+		if (config.getViewSite() instanceof ICommonViewerWorkbenchSite)
+			workbenchSite = (ICommonViewerWorkbenchSite) config.getViewSite();
+
+		fStateModel = config.getExtensionStateModel();
+//		WorkingSetModelManager workingSetModelManager = (WorkingSetModelManager) fStateModel
+//				.getProperty(WorkingSetModelManager.INSTANCE_KEY);
+
+		fLayoutActionGroup = new CommonLayoutActionGroup(config
+				.getStructuredViewer(), fStateModel);
+
+		if (workbenchSite != null) {
+//			fViewActionGroup = new ViewActionGroup(
+//					ViewActionGroup.SHOW_PROJECTS, /*workingSetModelManager,*/
+//					workbenchSite.getSite());
+			if (workbenchSite.getPart() != null
+					&& workbenchSite.getPart() instanceof IViewPart) {
+				fCCPGroup = new CCPActionGroup((IViewPart) workbenchSite
+						.getPart());
+			}
+
+		}
+
+	}
+
+	public void init(final String extensionId, final IViewPart viewPart,
+			final INavigatorContentService contentService,
+			final StructuredViewer structuredViewer) {
+
+	}
+
+	public void restoreState(IMemento memento) {
+		super.restoreState(memento);
+		restoreLayoutState(memento);
+	}
+
+	private void restoreLayoutState(IMemento memento) {
+		boolean isCurrentLayoutFlat = true;
+		Integer state = null;
+		if (memento != null)
+			state = memento.getInteger(TAG_LAYOUT);
+
+		// If no memento try an restore from preference store
+		if (state == null) {
+			IPreferenceStore store = JavaPlugin.getDefault()
+					.getPreferenceStore();
+			state = new Integer(store.getInt(TAG_LAYOUT));
+		}
+
+		if (state.intValue() == FLAT_LAYOUT)
+			isCurrentLayoutFlat = true;
+		else if (state.intValue() == HIERARCHICAL_LAYOUT)
+			isCurrentLayoutFlat = false;
+
+		fStateModel.setBooleanProperty(Values.IS_LAYOUT_FLAT,
+				isCurrentLayoutFlat);
+		fLayoutActionGroup.setFlatLayout(isCurrentLayoutFlat);
+	}
+
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,191 @@
+/***************************************************************************************************
+ * Copyright (c) 2000, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IResource;
+
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Image;
+
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.jface.viewers.ILabelDecorator;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.ITreeContentProvider;
+
+import org.eclipse.ui.IMemento;
+import org.eclipse.ui.navigator.ICommonLabelProvider;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+
+import org.eclipse.jdt.core.IJavaElement;
+
+import org.eclipse.jdt.ui.JavaElementLabels;
+
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+import org.eclipse.jdt.internal.ui.viewsupport.AppearanceAwareLabelProvider;
+import org.eclipse.jdt.internal.ui.viewsupport.JavaElementImageProvider;
+
+/**
+ * Provides the labels for the Package Explorer.
+ * <p>
+ * It provides labels for the packages in hierarchical layout and in all other
+ * cases delegates it to its super class.
+ * </p>
+ * 
+ * @since 2.1
+ */
+public class PreferenceAwareLabelProvider implements ICommonLabelProvider {
+
+	private final long LABEL_FLAGS = JavaElementLabels.DEFAULT_QUALIFIED
+			| JavaElementLabels.ROOT_POST_QUALIFIED
+			| JavaElementLabels.APPEND_ROOT_PATH
+			| JavaElementLabels.M_PARAMETER_TYPES
+			| JavaElementLabels.M_PARAMETER_NAMES
+			| JavaElementLabels.M_APP_RETURNTYPE
+			| JavaElementLabels.M_EXCEPTIONS
+			| JavaElementLabels.F_APP_TYPE_SIGNATURE
+			| JavaElementLabels.T_TYPE_PARAMETERS;
+
+	private PackageExplorerLabelProvider delegeteLabelProvider;
+
+	private PackageExplorerContentProvider fContentProvider;
+
+	private IExtensionStateModel fStateModel;
+
+	public PreferenceAwareLabelProvider() {
+
+	}
+
+	public void init(IExtensionStateModel aStateModel,
+			ITreeContentProvider contentProvider) {
+		fStateModel = aStateModel;
+
+		fContentProvider = (PackageExplorerContentProvider) contentProvider;
+		delegeteLabelProvider = createLabelProvider();
+
+		delegeteLabelProvider.setIsFlatLayout(fStateModel
+				.getBooleanProperty(Values.IS_LAYOUT_FLAT));
+		fStateModel.addPropertyChangeListener(new IPropertyChangeListener() {
+			public void propertyChange(PropertyChangeEvent event) {
+				if (Values.IS_LAYOUT_FLAT.equals(event.getProperty())) {
+					if (event.getNewValue() != null) {
+						boolean newValue = ((Boolean) event.getNewValue())
+								.booleanValue() ? true : false;
+						delegeteLabelProvider.setIsFlatLayout(newValue);
+					}
+				}
+
+			}
+		});
+	}
+
+	public String getDescription(Object anElement) {
+		return formatMessage(anElement);
+	}
+
+	private PackageExplorerLabelProvider createLabelProvider() {
+
+		return new PackageExplorerLabelProvider(
+				AppearanceAwareLabelProvider.DEFAULT_TEXTFLAGS
+						| JavaElementLabels.P_COMPRESSED,
+				AppearanceAwareLabelProvider.DEFAULT_IMAGEFLAGS
+						| JavaElementImageProvider.SMALL_ICONS,
+				fContentProvider);
+
+	}
+
+	public void dispose() {
+		delegeteLabelProvider.dispose();
+	}
+
+	public void propertyChange(PropertyChangeEvent event) {
+		delegeteLabelProvider.propertyChange(event);
+	}
+
+	public void addLabelDecorator(ILabelDecorator decorator) {
+		delegeteLabelProvider.addLabelDecorator(decorator);
+	}
+
+	public void addListener(ILabelProviderListener listener) {
+		delegeteLabelProvider.addListener(listener);
+	}
+
+	public Color getBackground(Object element) {
+		return delegeteLabelProvider.getBackground(element);
+	}
+
+	public Color getForeground(Object element) {
+		return delegeteLabelProvider.getForeground(element);
+	}
+
+	public Image getImage(Object element) {
+		return delegeteLabelProvider.getImage(element);
+	}
+
+	public boolean isLabelProperty(Object element, String property) {
+		return delegeteLabelProvider.isLabelProperty(element, property);
+	}
+
+	public void removeListener(ILabelProviderListener listener) {
+		delegeteLabelProvider.removeListener(listener);
+	}
+
+	public boolean equals(Object obj) {
+		return delegeteLabelProvider.equals(obj);
+	}
+
+	public int hashCode() {
+		return delegeteLabelProvider.hashCode();
+	}
+
+	public String toString() {
+		return delegeteLabelProvider.toString();
+	}
+
+	public String getText(Object element) {
+		return delegeteLabelProvider.getText(element);
+	}
+
+	public void setIsFlatLayout(boolean state) {
+		delegeteLabelProvider.setIsFlatLayout(state);
+	}
+
+	// Taken from StatusBarUpdater
+
+	protected String formatMessage(Object element) {
+		if (element instanceof IJavaElement) {
+			return formatJavaElementMessage((IJavaElement) element);
+		} else if (element instanceof IResource) {
+			return formatResourceMessage((IResource) element);
+		}
+		return ""; //$NON-NLS-1$
+	}
+
+	private String formatJavaElementMessage(IJavaElement element) {
+		return JavaElementLabels.getElementLabel(element, LABEL_FLAGS);
+	}
+
+	private String formatResourceMessage(IResource element) {
+		IContainer parent = element.getParent();
+		if (parent != null && parent.getType() != IResource.ROOT)
+			return element.getName() + JavaElementLabels.CONCAT_STRING
+					+ parent.getFullPath().makeRelative().toString();
+		else
+			return element.getName();
+	}
+
+	public void restoreState(IMemento aMemento) {
+
+	}
+
+	public void saveState(IMemento aMemento) {
+
+	}
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,23 @@
+/***************************************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+
+public interface IExtensionStateConstants {
+ 
+	String ROOT_MODE= "rootMode"; //$NON-NLS-1$ 
+
+	interface Values {
+
+		String IS_LAYOUT_FLAT= "isLayoutFlat"; //$NON-NLS-1$
+ 
+
+	}
+
+}
